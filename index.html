<html manifest="cache.manifest" ng-app="myApp" content="text/html;charset=UTF-8">
<head>
    <title>Archery Scope Interpolation</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link href='kghostview.png' rel='apple-touch-icon' type='image/png'>
    <script src="svg.min.js"> </script>
    <script src="FileSaver.min.js"> </script>
    <script src="angular.min.js"></script>
    <script src="numeric-1.2.6.js"></script>
    <style type="">
    .tdslope { width:250px }
    table { margin:auto; font-family:monospace; border-width:1px; border-collapse: collapse; border-style: solid; }
    td, th { min-width:50px; border-width:1px; border-style: solid; text-align:center; }
    .tdcontrols { height:36px }
    .parallax { background-color: #CCC; }
    .parallax-wrong { text-decoration: line-through; }
    .tenmeters { background-color: #FCC; font-weight: bold }
    .twometers { background-color: #FFC; }
    .storage-warning { max-width:260px; font-family:Helvetica; font-size:0.7rem; }
    .helptext-td { max-width:360px; font-family:Helvetica; font-size:0.7rem; text-align: left; }
    
    .polyfit-color-high { background-color:#FF5E23 }
    .polyfit-color-low { background-color:#237BFF }
    
    @media print 
    { 
        table { page-break-after:always; }
        tr    { page-break-inside:avoid; page-break-after:auto }
        input, button { border-width:0px; border:none; }
        .do-not-print { display:none; }
    }
    </style>
<script>

    var app = angular.module('myApp', []);
    app.config(['$controllerProvider', function($controllerProvider) {
      // this option might be handy for migrating old apps, but please don't use it in new ones!
      $controllerProvider.allowGlobals();
    }]);

    function getParameterByName(name) { // GET parameter ?data=
    name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
    var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
        results = regex.exec(location.search);
    return results == null ? "" : results[1];
}

function getHashbangParameter(parameterName,defaultValue)
    { 
        if(parameterName instanceof Array)
        {
            for(var i in parameterName)
            {
                var ret = this.getHashbangParameter(parameterName[i], null);
                if(ret !== null)
                    return ret;
            }
            
            return defaultValue;
        }
        
        defaultValue = defaultValue || null;
        if( !parameterName )
            throw new Error("getHashbangParameter: 'parameterName' is missing!");

        // parameter schema: "/paramName/:paramValue/" 
        var regex = new RegExp("/"+parameterName+"/([^/#&]+)"); // [A-Za-z0-9_%]
        var match = window.location.href.match(regex);
        return match ? match[1] : defaultValue;
    };

function calculateIntegerHashFromString(s)
    {
        return s.split("").reduce(function(a,b){a=((a<<5)-a)+b.charCodeAt(0);return a&a},0);              
    }
        


    // http://blog.ivank.net/interpolation-with-cubic-splines.html
	function CSPL()
	{
	    this.xs = [];
	    this.ys = [];
	    this.ks = [];
	}
	
	CSPL._gaussJ = {};
	CSPL._gaussJ.solve = function(A, x)	// in Matrix, out solutions
	{
		var m = A.length;
		for(var k=0; k<m; k++)	// column
		{
			// pivot for column
			var i_max = 0; var vali = Number.NEGATIVE_INFINITY;
			for(var i=k; i<m; i++) if(A[i][k]>vali) { i_max = i; vali = A[i][k];}
			CSPL._gaussJ.swapRows(A, k, i_max);
			
			if(A[i_max][i] == 0) console.log("matrix is singular!");
			
			// for all rows below pivot
			for(var i=k+1; i<m; i++)
			{
				for(var j=k+1; j<m+1; j++)
					A[i][j] = A[i][j] - A[k][j] * (A[i][k] / A[k][k]);
				A[i][k] = 0;
			}
		}
		
		for(var i=m-1; i>=0; i--)	// rows = columns
		{
			var v = A[i][m] / A[i][i];
			x[i] = v;
			for(var j=i-1; j>=0; j--)	// rows
			{
				A[j][m] -= A[j][i] * v;
				A[j][i] = 0;
			}
		}
	}
	
	CSPL._gaussJ.zerosMat = function(r,c) {var A = []; for(var i=0; i<r; i++) {A.push([]); for(var j=0; j<c; j++) A[i].push(0);} return A;}
	CSPL._gaussJ.printMat = function(A){ for(var i=0; i<A.length; i++) console.log(A[i]); }
	CSPL._gaussJ.swapRows = function(m, k, l) {var p = m[k]; m[k] = m[l]; m[l] = p;}
		
	CSPL.prototype.getNaturalKs = function(xs, ys)	// in x values, in y values, out k values
	{
	    this.xs = xs;
	    this.ys = ys;
	    CSPL._getNaturalKs(xs, ys, this.ks);
	};
	
	CSPL._getNaturalKs = function(xs, ys, ks)	// in x values, in y values, out k values
	{
		var n = xs.length-1;
		var A = CSPL._gaussJ.zerosMat(n+1, n+2);
			
		for(var i=1; i<n; i++)	// rows
		{
			A[i][i-1] = 1/(xs[i] - xs[i-1]);
			
			A[i][i  ] = 2 * (1/(xs[i] - xs[i-1]) + 1/(xs[i+1] - xs[i])) ;
			
			A[i][i+1] = 1/(xs[i+1] - xs[i]);
			
			A[i][n+1] = 3*( (ys[i]-ys[i-1])/((xs[i] - xs[i-1])*(xs[i] - xs[i-1]))  +  (ys[i+1]-ys[i])/ ((xs[i+1] - xs[i])*(xs[i+1] - xs[i])) );
		}
		
		A[0][0  ] = 2/(xs[1] - xs[0]);
		A[0][1  ] = 1/(xs[1] - xs[0]);
		A[0][n+1] = 3 * (ys[1] - ys[0]) / ((xs[1]-xs[0])*(xs[1]-xs[0]));
		
		A[n][n-1] = 1/(xs[n] - xs[n-1]);
		A[n][n  ] = 2/(xs[n] - xs[n-1]);
		A[n][n+1] = 3 * (ys[n] - ys[n-1]) / ((xs[n]-xs[n-1])*(xs[n]-xs[n-1]));
			
		CSPL._gaussJ.solve(A, ks);		
	};
		
	CSPL.prototype.evalSpline = function(x)
	{
	    return CSPL._evalSpline(x, this.xs, this.ys, this.ks);
	};
	
	CSPL._evalSpline = function(x, xs, ys, ks)
	{
		var i = 1;
		while(xs[i]<x) // breaks beyond array undefined < any
		    i++;
		
		// extrapolate far
		if(i == xs.length)
		    i--;
		    
		var t = (x - xs[i-1]) / (xs[i] - xs[i-1]);
		
		var a =  ks[i-1]*(xs[i]-xs[i-1]) - (ys[i]-ys[i-1]);
		var b = -ks[i  ]*(xs[i]-xs[i-1]) + (ys[i]-ys[i-1]);
		
		var q = (1-t)*ys[i-1] + t*ys[i] + t*(1-t)*(a*(1-t)+b*t);
		return q;
	};

	function polynomialCurveFitting(xArray, yArray)
	{
        order = 2;
        
        var xMatrix = [];
        var xTemp = [];
        var yMatrix = numeric.transpose([yArray]);
        
        for (j=0;j<xArray.length;j++)
        {
            xTemp = [];
            for(i=0;i<=order;i++)
            {
                xTemp.push(1*Math.pow(xArray[j],i));
            }
            xMatrix.push(xTemp);
        }
        
        var xMatrixT = numeric.transpose(xMatrix);
        var dot1 = numeric.dot(xMatrixT,xMatrix);
        var dotInv = numeric.inv(dot1);
        var dot2 = numeric.dot(xMatrixT,yMatrix);
        var solution = numeric.dot(dotInv,dot2);
        //console.log("Coefficients a + bx^1 + cx^2...");
        //console.log(solution);
        return solution;
    };

function LocalStorageManager(localStorageId, scope, objectKey, dbKey, defaultId, defaultObject)
{
    // maintains localStorageId_current and localStorageId_DB
    
    this.localStorageId = localStorageId;
    this.scope = scope;
    this.objectKey = objectKey;
    this.dbKey = dbKey;
    
    this.scope[this.objectKey] = {};
    this.scope[this.objectKey]['key'] = defaultId;
    this.scope[this.objectKey]['object'] = defaultObject;
    this.scope[this.dbKey] = {};  // always { id1:object1, id2:object2, ... }
    
    this.load();
    this.restore(null);
}

LocalStorageManager.prototype._currentToJSON = function() // save the current Item temporarily in LS
    {
        return angular.toJson([this.scope[this.objectKey]['key'], this.scope[this.objectKey]['object']]);
    }
    
LocalStorageManager.prototype._currentFromJSON = function(current) // save the current Item temporarily in LS
    {
        if(current[0])
        {
            this.scope[this.objectKey]['key'] = current[0];
            this.scope[this.objectKey]['object'] = current[1];
        }
    };
    
LocalStorageManager.prototype.currentToURIComponent = function() // save the current Item temporarily in LS
    {
        return btoa ? encodeURIComponent(btoa(this._currentToJSON())) : "ERROR_btoa_not_supported";
    };
    
LocalStorageManager.prototype.currentFromURIComponent = function(uric) // save the current Item temporarily in LS
    {
        var b64 = decodeURIComponent(uric);
    
        try
        {
            var json = atob(b64);
            this._currentFromJSON(json);
            return true;
        }
        catch(e) 
        {
            console.log("Cannot decode! The data is invalid.");
        }
        
        return false;
    };

LocalStorageManager.prototype.save = function() // save the current Item temporarily in LS
    {
        localStorage.setItem(this.localStorageId + "_current", this._currentToJSON());
        //console.log("LS SAVE", this.scope[this.objectKey]['key']);
    };

LocalStorageManager.prototype.load = function(id) // load current item os startup
    {
        var current = this._getItemAndDecode(this.localStorageId + "_current",[null, null]);
        this._currentFromJSON(current);
    };

LocalStorageManager.prototype.store = function() // save the current Item in LS DB
    {
        this.scope[this.dbKey] = this._getItemAndDecode(this.localStorageId + "_DB", {});
        this.scope[this.dbKey][this.scope[this.objectKey]['key']] = this.scope[this.objectKey]['object'];
        localStorage.setItem(this.localStorageId + "_DB", angular.toJson(this.scope[this.dbKey]));
    };

LocalStorageManager.prototype.delete = function(idKey) // save the current Item in LS DB
    {
        this.scope[this.dbKey] = this._getItemAndDecode(this.localStorageId + "_DB", {});
        delete this.scope[this.dbKey][idKey];
        localStorage.setItem(this.localStorageId + "_DB", angular.toJson(this.scope[this.dbKey]));
    };

LocalStorageManager.prototype.restore = function(idOrNull) // save the current Item in LS DB
    {
        this.scope[this.dbKey] = this._getItemAndDecode(this.localStorageId + "_DB");
        
        if(!idOrNull)
            return;
            
        var obj = this.scope[this.dbKey][idOrNull];
        if(obj)
        {
            this.scope[this.objectKey]['key'] = idOrNull;
            this.scope[this.objectKey]['object'] = obj;
        }
    };

LocalStorageManager.prototype._getItemAndDecode = function(id, _default) // save the current Item in LS DB
    {
        var ls = localStorage.getItem(id);
        if(ls)
        {
            try
            {
                return angular.fromJson(ls);
            }
            catch(e) 
            {
                console.log("JSON PARSE ERROR");
            }
        }
        
        return _default;
    };

function Calculator($rootScope)
{
    this.scope = $rootScope;
    DEBUG_SCOPE = $rootScope;    
    
    this.scope.Math = window.Math; // we need Math in the template
    
    this.scope.inputs = { 
        arrow:{ grains:400, name:"Arrow One" },
        settings:[], // { distance:, reading: }
        v0fps:245,
        v0:74,
        maxDistance:60
        };
    
    this.scope.savedSettings = {};

    var me = this;
    
    this.scope.parcour = null; // {key:, value:} Array of target objects { id:"1 Adler", d:10.5, a:-25 }, ...        
    this.scope.parcourStore = null; // Array of target objects { id:"1 Adler", d:10.5, a:-25 }, ...        
    this.localStorageParcour = new LocalStorageManager("ARCHISCOPE_parcour", this.scope, "parcour", "parcourStore", "WBSC Rot", [{ id:"1 Dachs", d:23, a:-11 }, { id:"2 Fuchs", d:24, a:-16 }]);
    this.scope.$watch("parcour", function(id){ me.localStorageParcour.save(); }, true);
    
    //this.scope.$watch("inputs.arrow.weightAll", function(){ me.scope.inputs.arrow.grams = me.scope.inputs.arrow.weightAll/me.scope.inputs.arrow.count; });
    //this.scope.$watch("inputs.arrow.count", function(){ me.scope.inputs.arrow.grams = me.scope.inputs.arrow.weightAll/me.scope.inputs.arrow.count; });
    //this.scope.$watch("inputs.arrow.grams", function(){ me.scope.inputs.arrow.grains = me.scope.inputs.arrow.grams * 15.432358; });
    this.scope.$watch("inputs.arrow.name", function(){ me.scope.inputs.settingsName = me.scope.inputs.arrow.name + " " + (new Date()).toISOString().substring(2,10); });
    
    this.maxTable = 90;
    
    this.parallax = 16; // meters
    
    this.cubicSpline = null; // interpolator for 16+ meters
    this.cubicSplineBunnyshot = null; // interpolator for few meters
    
    this.scope.$watch("inputs.maxDistance", function(){ me.calcModel(); });
    this.scope.$watch("model", function(){ me.calcTable(); }, true);
    
    this.load();
    
    this.scope.$watch("inputsJSON", function() {
        me.scope.inputsURI = btoa ? encodeURIComponent(btoa(me.scope.inputsJSON)) : "ERROR_btoa_not_supported";
        me.updateUrlParameter(); }, true);
    
    this.scope.$watch("inputs.v0fps", function(){ me.scope.inputs.v0 = Math.round(me.scope.inputs.v0fps * 0.3048); me.calcTable(); });
    
    this.scope.clearLocalStorage = function() { me.clear(); };
    this.scope.saveSettings = function() { me.saveSettings(); };
    this.scope.loadSettings = function(x) { me.loadSettings(x); };
    this.scope.deleteSettings = function(x) { if(confirm('Delete?')) { me.deleteSettings(x); } };
    
    this.scope.$watch("inputs", function(){  
        document.title = me.scope.inputs.settingsName; 
        me.scope.inputsJSON = angular.toJson(me.scope.inputs); }, true);
    
    this.scope.showScaleAndSVG = false; // disables calcSvgModel()
    this.scope.inputs.svgScaleX = 1.0;
    this.scope.$watch("inputs.svgScaleX", function(){ me.calcSvgModel(); });
        
    this.scope.calculator = this;
}

Calculator.prototype.setExpandedModelDistance = function(d)
{
    var d = Math.floor(d/2)*2;
    if(d == this.expandedModelDistance)
        this.expandedModelDistance = 0;
    else
        this.expandedModelDistance = d;
}

Calculator.prototype.getUrlParameter = function() // return json as string
{
    var data = null;
    // 1. check the hashbang parameter #!/scope/{encodedData}
    data = getHashbangParameter("sight",null);
    
    // 2. else check the GET ?data= parameter for backwards compatibility
    if(!data)  // we have the GET parameter ?data=
        data = getParameterByName("data");
        
    if(!data)
        return null;
        
    // 3. decode the data
    data = decodeURIComponent(data);
    
    try
    {
        data = atob(data);
    }
    catch(e) 
    {
        alert("Passed scope readings cannot be decoded! The data is invalid.");
        return null;
    }
    
    return data; // return json as string
};

Calculator.prototype.updateUrlParameter = function() // renew the hashbang parameter
{
    document.title = this.scope.inputs.settingsName; 
    this.scope.inputsURI = btoa ? encodeURIComponent(btoa(this.scope.inputsJSON)) : "ERROR_btoa_not_supported";
    
    this.scope._dataParamHash = calculateIntegerHashFromString(this.scope.inputsJSON); // json string of this.scope.inputsJSON
    
    if(getParameterByName("data")) // strip the old get parameter
        window.history.replaceState(null, null, window.location.pathname);

    var s = "!/sight/" + this.scope.inputsURI;
    this.scope.parcourURI = "/parcour/" + this.localStorageParcour.currentToURIComponent();
    window.location.hash = s + this.scope.parcourURI;
    
    console.log("SET #!", s.length, this.scope.parcourURI.length)
};

Calculator.prototype.load = function()
{
    var ls = localStorage.getItem('ARCHISCOPE_savedSettings');
    if(ls)
    {
        try
        {
            this.scope.savedSettings = angular.fromJson(ls);
        }
        catch(e) 
        {
            console.log("ARCHISCOPE_savedSettings JSON PARSE ERROR");
        }
    }
        
    var inp = localStorage.getItem('ARCHISCOPE_scopeinputs');
    if(inp)
    {
        try
        {
            this.scope.inputs = angular.fromJson(inp);
            this.scope.inputsJSON = inp;
            this.scope._dataParamHash = calculateIntegerHashFromString(inp); // json this.scope.inputsJSON 
        }
        catch(e) 
        {
            console.log("ARCHISCOPE_scopeinputs JSON PARSE ERROR");
        }        
    }
    
    var data = this.getUrlParameter();  // return json as string
    if(data)  // we have the GET parameter ?data=
    {
        // avoid confirm on every opening of page, only if data= is new
        var hash = calculateIntegerHashFromString(data);
        if(hash != this.scope._dataParamHash)
        {
            if(confirm("Replace saved data from URL?") === true)
            {
                this.scope.inputs = angular.fromJson(data);
                this.scope._dataParamHash = hash;
                this.save();
            }
        }
    }
    
    var parcour = getHashbangParameter("parcour", null);
    if(parcour)
    {
        var hashURIC = calculateIntegerHashFromString(parcour);
        var hashCurrent = calculateIntegerHashFromString(this.localStorageParcour.currentToURIComponent());
        if(hashURIC != hashCurrent)
        {
            if(confirm("Replace parcour from URL?") === true)
            {
                this.localStorageParcour.currentFromURIComponent(parcour);
                this.save();
            }
        }    
    }
};

Calculator.prototype.save = function() // this is the instant save function
{
    this.scope.inputsJSON = angular.toJson(this.scope.inputs);
    this.updateUrlParameter();
    
    localStorage.setItem('ARCHISCOPE_scopeinputs', this.scope.inputsJSON);
    
    var json = angular.toJson(this.scope.savedSettings);
    localStorage.setItem('ARCHISCOPE_savedSettings', json);
    
    this.localStorageParcour.save();
};

Calculator.prototype.clear = function()
{
    // localStorage.clear(); removes all site settings, scoresheets, etc.
    
    localStorage.removeItem('ARCHISCOPE_scopeinputs');
    localStorage.removeItem('ARCHISCOPE_savedSettings');
    localStorage.removeItem('ARCHISCOPE_parcour');
    
    window.location.search="?reload=1";
};

Calculator.prototype.saveSettings = function()
{
    if(!this.scope.inputs.settingsName) // undefined or empty
    {
        alert("Name of scope readings is empty! Cannot save.");
        return;
    }
    
    this.scope.savedSettings[this.scope.inputs.settingsName] = this.scope.inputs.settings;
    this.save();
};

Calculator.prototype.loadSettings = function(name)
{
    this.scope.inputs.settings = this.scope.savedSettings[name];
    this.scope.inputs.settingsName = name;
    this.calcModel();
};

Calculator.prototype.deleteSettings = function(name)
{
    delete this.scope.savedSettings[name];
    this.save();
};

Calculator.prototype.calcModel = function()  // create the distance model; does not change when inputs are changed, see calcTable()
{
    this.scope.model = [];
    
    var max = this.scope.inputs.maxDistance;
    for(var j=0; j<this.scope.inputs.settings.length; j++) // do not discard user data
        if(this.scope.inputs.settings[j].distance > max)
            max = this.scope.inputs.settings[j].distance;
                    
    var i=0, step=1;
    for(var d = 4; d < max; d+=step) // d is the distance to the target           
    {
        if(d>=this.expandedModelDistance && d<this.expandedModelDistance+2)
            step = 0.25;
        else
        if(d>11) // above 11m switch to 2
            step = 2;
        else
            step = 1;
            
        
        if(typeof(this.scope.inputs.maxDistance) == "number" && d > max)
            break;
            
        this.scope.model[i] = {};
        
        this.scope.model[i].distance = d;
        this.scope.model[i].reading = 0;
        
        for(var j=0; j<this.scope.inputs.settings.length; j++)
            if(this.scope.inputs.settings[j].distance == d)
                this.scope.model[i].reading = this.scope.inputs.settings[j].reading; 
                
        i++;
    }                        
};

Calculator.prototype.calcTable = function()
{
    var n = 0;
    
    this.scope.inputs.settings = []; // clear saved data
    
    var xs0=[], ys0=[], x0n = 0;  // cubic spline
    var xs=[], ys=[], xn = 0;  // cubic spline
    
    xs0[x0n] = 0;
    ys0[x0n] = 80;
    x0n++;
    
    for(var i = 0; i < this.scope.model.length; i++)
    {
        if(this.scope.model[i].reading > 0)  // COPY READING TO SETTINGS!
        {
            this.scope.inputs.settings[n] = {};
            this.scope.inputs.settings[n].distance = this.scope.model[i].distance;
            this.scope.inputs.settings[n].reading = this.scope.model[i].reading;
            n++;
            
            if(this.scope.model[i].distance < this.parallax) // must avoid paralax error!!
            {
                xs0[x0n] = this.scope.model[i].distance;
                ys0[x0n] = this.scope.model[i].reading;
                x0n++;
            }
            else
            {
                xs[xn] = this.scope.model[i].distance;
                ys[xn] = this.scope.model[i].reading;
                xn++;
            }
        }
    }
        
    
    this.save();
    
    if(n < 3)
        return;
    
    if(xn >= 3) // more than 3 values > this.parallax
    {
        this.cubicSpline = new CSPL();
        this.cubicSpline.getNaturalKs(xs, ys);
        this.calcPolyfit();
    }
    else
        this.cubicSpline = null;
    
    
    if(x0n >= 3) // more than 3 values < this.parallax
    {
        // Join the splines ...
        xs0[x0n] = this.parallax;
        ys0[x0n] = this.cubicSpline.evalSpline(this.parallax);;
        x0n++;
    
        this.cubicSplineBunnyshot = new CSPL();
        this.cubicSplineBunnyshot.getNaturalKs(xs0, ys0);
    }
    else
        this.cubicSplineBunnyshot = null;
    
    for(var i = 0; i < this.scope.model.length; i++)
    {
        this.scope.model[i].polyfit = this.evalPolyfit(this.scope.model[i].distance);
        
        var y = this.evalSpline(this.scope.model[i].distance);
        this.scope.model[i].interpolated = y.toFixed(2); // WARNING this is a String!
        var y2 = this.evalSpline(this.scope.model[i].distance+1);
        this.scope.model[i].delta1m = (y2-y).toFixed(2); // WARNING this is a String!
        if(i>0) // 2nd derivative of change
            this.scope.model[i].delta2nd= (this.scope.model[i].delta1m - this.scope.model[i-1].delta1m).toFixed(2); // WARNING this is a String!
    }
            
    this.calcSlope();
};

Calculator.prototype.evalSpline = function(distance) // handle parallax
{
    if(distance < this.parallax)
    {
        if(this.cubicSplineBunnyshot)
            return this.cubicSplineBunnyshot.evalSpline(distance);
        
        return 0;
    }
    
    if(this.cubicSpline)
        return this.cubicSpline.evalSpline(distance);
        
    return 0;
}

Calculator.prototype.calcPolyfit = function()
{
    var xMeters = [];
    var yReadings = [];
    
    for(var j=0; j<this.scope.inputs.settings.length; j++)
    {
        if(this.scope.inputs.settings[j].distance < 20)
            continue;
            
        xMeters.push(this.scope.inputs.settings[j].distance);
        yReadings.push(this.scope.inputs.settings[j].reading);
        // console.log(this.scope.inputs.settings[j].distance + "," + this.scope.inputs.settings[j].reading);
    }
    
    if(xMeters.length >= 2)
        this.polynomial = polynomialCurveFitting(xMeters, yReadings);
    else
        this.polynomial = null;
};

Calculator.prototype.evalPolyfit = function(xMeters)
{
    if(xMeters < 18 || !this.polynomial)
        return NaN;
    // var xMeters = model.distance;
    var r = this.polynomial[0][0] + this.polynomial[1][0] * xMeters + this.polynomial[2][0] * xMeters * xMeters;
    return Math.round(r*100)/100;
};

Calculator.prototype.calcSlope = function()
{
    var d2r = Math.PI/180; // deg to rad
    
    for(var i = 0; i < this.scope.model.length; i++)
    {
        var d = this.scope.model[i].distance;
        var cd;
        cd = Math.cos(10*d2r) * d; this.scope.model[i].down10 = cd.toFixed(1); // CSPL.evalSpline(cd, xs, ys, ks).toFixed(2);
        cd = Math.cos(20*d2r) * d; this.scope.model[i].down20 = cd.toFixed(1); // CSPL.evalSpline(cd, xs, ys, ks).toFixed(2);
        cd = Math.cos(30*d2r) * d; this.scope.model[i].down30 = cd.toFixed(1); // CSPL.evalSpline(cd, xs, ys, ks).toFixed(2);
        cd = Math.cos(40*d2r) * d; this.scope.model[i].down40 = cd.toFixed(1); // CSPL.evalSpline(cd, xs, ys, ks).toFixed(2);
        cd = Math.cos(50*d2r) * d; this.scope.model[i].down50 = cd.toFixed(1); // CSPL.evalSpline(cd, xs, ys, ks).toFixed(2);
        
        var time = d/this.scope.inputs.v0;
        var drop = 9.81/2.0*time*time*100;
        this.scope.model[i].time = time.toFixed(2);
        this.scope.model[i].drop = drop.toFixed(0); // excludes drag / air resistance
        
        var t1 = (d-1)/this.scope.inputs.v0;
        var d1 = 9.81/2.0*t1*t1*100; // *100 cm
        this.scope.model[i].deltaScope = Math.round((drop-d1)/this.scope.model[i].delta1m);  // 1 REV on scope is x cm on target 
    }
};

Calculator.prototype.calcSvgModel = function()
{
    if(false == this.scope.showScaleAndSVG) // hidden
        return;
        
    this.svgModel = [];
    
    var calcOneAngle = function(a, model)
    {
        var minReading = 999;
        for(var d=70; d>=10; d-=2) // parallax error prohibits plotting 5m values
        {
            var p = { distance:d , reading:0, angle:a };
            var realD = p.distance * Math.cos(a * d2r);
            p.reading = this.evalSpline(realD);
            
            minReading = Math.min(minReading, p.reading);
            //console.log(a, p.reading, minReading);
            if(p.reading <= minReading) // avoid plotting parallax area
                model.push(p);
        }
        
        return minReading;
    };
    
    var d2r = Math.PI/180; // deg to rad

    // for every range and angle calc a data point
    calcOneAngle(0, this.svgModel);
    //calcOneAngle(0, this.svgModel);
    calcOneAngle(10, this.svgModel);
    calcOneAngle(15, this.svgModel);
    calcOneAngle(20, this.svgModel);
    calcOneAngle(25, this.svgModel);
    calcOneAngle(30, this.svgModel);
    calcOneAngle(40, this.svgModel);
    calcOneAngle(50, this.svgModel);
    
    if(!this.svg)
        this.svg = SVG('scale').attr({ width:"94mm", height:"20mm", preserveAspectRatio:"xMinYMin" }).viewbox(0,0,89,20)
    else
        this.svg.clear();
    
    var group = this.svg.group().transform({scaleX: this.scope.inputs.svgScaleX });
        
    for(var i in this.svgModel)
    {
        var m = this.svgModel[i];
        //console.log(m.reading, m.angle);
        var w = 0.1;
        var h = 0.9;
        var y0 = 0;
        
        if(m.angle == 0) // make y-space for numbers
            y0 = 0.1;
            
        if(m.distance % 10 == 0)
        {
            w=0.4;
            
            if(m.angle == 0)
                group.text(""+m.distance).size(1.2).move(m.reading - w/2.0 -0.50, y0 + 8.75);
        }
        else if(m.distance % 2 == 0)
            h=0.5;
    
        group.rect(w, h).move(m.reading - w/2.0, y0 + 10-(m.angle)/5);        
    }
        
    group.rect(0.1, 11).move(6, 0);
    group.rect(0.1, 11).move(88, 0);
    
    group.text(this.scope.inputs.settingsName).size(3).move(55, 0);
    var px = this.getParallaxReadings();
    if(px)
    {
        var z1 = "", z2 = "", z3 = "";
        for(var i=0;i< px.length; i++)
        {
            if(i<4)
                z1 += px[i]+" ";
            else if(i<7)
                z2 += px[i]+" ";
            else
                z3 += px[i]+" ";
        }
        
        var y = 3.2;
        group.text(z1).size(2.5).move(55, y);
        group.text(z2).size(2.5).move(58, y+2.6);
        group.text(z3).size(2.5).move(61, y+2.6+2.6);
    }
    
    var xml= document.getElementById('scale').innerHTML;
    document.getElementById('svgxml').innerText = xml;
    //return this.svgModel;
};

Calculator.prototype.getParallaxReadings = function()
{
    var ret = []; // must not be ""
    
    for(var i = 0; i < this.scope.model.length; i++)
    {
        if(this.scope.model[i].distance > this.parallax) // normal
            continue;
            
        if(this.scope.model[i].reading > 0)
            ret.push(this.scope.model[i].distance +"/"+ this.scope.model[i].reading);
    }
   
    return ret;
};

Calculator.prototype.saveSvg = function()
{
    //var svgdom = document.getElementById("svgxml").innerText;
    var data = document.getElementById('scale').innerHTML;    
    var blob = new Blob([ data ], {type: "image/svg+xml;charset=utf-8"});
    saveAs(blob, "arrow.svg", true);  // true disables UTF-16/32 Byte Order Mark
};

Calculator.prototype.drawSvgShot = function(drawWhat)
{
    // similar as model, but for X,Y=distance,drop graph
    var max = this.scope.inputs.maxDistance;
    for(var j=0; j<this.scope.inputs.settings.length; j++) // do not discard user data
        if(this.scope.inputs.settings[j].distance > max)
            max = this.scope.inputs.settings[j].distance;
                    
    var step=.5;
    var distDropGraph = []; // [[x1,y1], ...]
    var distScopeGraph = []; // [[x1,y1], ...]
    var distScopePolyfit = []; // [[x1,y1], ...]
    for(var d = 0; d < max; d+=step) // d is the distance to the target           
    {
        if(typeof(this.scope.inputs.maxDistance) == "number" && d > max)
            break;
            
        var time = d/this.scope.inputs.v0;
        var drop = 9.81/2.0*time*time*10;
        var tuple = [d, drop];
        distDropGraph.push(tuple);
        //console.log(tuple);
        
        var scope = this.evalSpline(d);
        distScopeGraph.push([d, scope]);
        
        scope = this.evalPolyfit(d);
        if(scope > 0)
            distScopePolyfit.push([d, scope]);
    }                        

    if(!this.shotSvg)
        this.shotSvg = SVG('shotSVG').attr({ width:"300mm", height:"200mm", preserveAspectRatio:"xMinYMin" }).viewbox(0,0,300,200)
    else
        this.shotSvg.clear();
    
    var group = this.shotSvg.group().transform({scaleX: 3, scaleY:3 }); // 0..70 m, 0..300 cm
    
    group.fill('none').stroke({ width: 0.06 });
    
    // grid
    for(var i=10;i<=60;i+=10)
        group.line(i,0,i,300);
        
    if(drawWhat==1)
        group.polyline(distDropGraph).stroke({ width: 0.2 });
    else
    {
        group.polyline(distScopeGraph).stroke({ width: 0.2 });    
        group.polyline(distScopePolyfit).stroke({ width: 0.1, color:"#F00" });
    }
};

Calculator.prototype.transformScale = function()
{
    if(!this.transformScaleTo || !this.transformScaleFrom)
        return;
            
    var delta = this.transformScaleTo - this.transformScaleFrom;
    for(var j=0; j<this.scope.inputs.settings.length; j++) // do not discard user data
        this.scope.inputs.settings[j].reading += delta;
        
    this.transformScaleFrom = "";
    this.transformScaleTo = "";
    this.calcModel();    
};


Calculator.prototype.addRemoveTarget = function(i)
{
    if("" == this.scope.parcour.object[i].id)
        this.scope.parcour.object.splice(i,1);
    else
        this.scope.parcour.object.splice(i+1,0,{id:"",d:0,a:0});
};

Calculator.prototype.storeParcour = function() // store many parcours and retrieve them
{
    this.localStorageParcour.store();
};

Calculator.prototype.restoreParcour = function(key) // store many parcours and retrieve them
{
    this.localStorageParcour.restore(key);
    this.updateUrlParameter();
};

Calculator.prototype.deleteParcour = function(key) // store many parcours and retrieve them
{
    if(confirm("Delete " + key + "?") === true)
        this.localStorageParcour.delete(key);
};

</script>
</head>
<body>
    <div ng-controller="Calculator">
      <table id="table" style="min-width:260px">
      <tr>
        <th>Arrow Name</th>
        <td><input type="text" ng-model="inputs.arrow.name"></td>
      </tr>
      <tr>
        <th>Arrow grains</th>
        <td><input type="number" ng-model="inputs.arrow.grains"></td>
      </tr>
      <tr>
        <th>V0 fps</th>
        <td><input type="number" ng-model="inputs.v0fps"></td>
      </tr>
      <tr>
        <th>V0 m/s</th>
        <td><input type="number" ng-model="inputs.v0"></td>
      </tr>
      <tr class="do-not-print">
        <th>Max Distance</th>
        <td><input type="number" ng-model="inputs.maxDistance"></td>
      </tr>
      <tr class="do-not-print">
        <th>Show drop</th>
        <td><input type="checkbox" ng-model="showDrop"></td>
      </tr>
      <tr class="do-not-print">
        <th>Show Polyfit</th>
        <td><input type="checkbox" ng-model="showPolyfit"></td>
      </tr>
      <!-- tr>
        <th>Inclinations</th>
        <td><input type="checkbox" ng-model="inputs.showInclination"></td>
      </tr -->
      <!-- tr>
        <th>Unit Meters</th>
        <td><input type="checkbox" ng-model="inputs.useMeters"></td>
      </tr-->
      <!-- tr>
        <th>Eye-Arrow d (mm)</th>
        <td><input type="number" ng-model="inputs.parallaxDistance"></td>
      </tr -->
      </table>
      
      <br/>

      <table id="table">
      <tr>
        <th colspan=2><input type="text" ng-model="inputs.settingsName" style="width:112px"></th>
        <th ng-show="showPolyfit">Fit</td>
        <th> m </th>
        <th> &delta;/m </th>
        <!-- th>10&deg; m</th>
        <th>20&deg; m</th>
        <th>30&deg; m</th>
        <th> m </th>
        <th>40&deg; m</th>
        <th>50&deg; m</th -->
        <th ng-show="showDrop">time s</th>
        <th ng-show="showDrop">drop cm</th>
        <th ng-show="showDrop">cm/rev</th>
      </tr> 
      <tr ng-repeat="i in model" ng-class="{parallax: i.distance<calculator.parallax, tenmeters: i.distance % 10 == 0, twometers: i.distance % 2 == 0 && i.distance % 10 != 0 && i.distance>=calculator.parallax}" >
        <td><input type="number" ng-model="i.reading" step="0.05" style="width:45px"></td>
        <td>{{ i.interpolated }} </td>
        <td ng-show="showPolyfit" ng-class="{'polyfit-color-high': i.reading > i.polyfit+0.05, 'polyfit-color-low': i.reading && i.reading < i.polyfit-0.05 }" >{{i.polyfit}}</td>
        <td><button style="width:100%" ng-click="calculator.setExpandedModelDistance(i.distance); calculator.calcModel()">{{i.distance}}m</button></td>
        <td ng-style="i.delta2nd<0 && i.distance>20 ? {'background-color':'#F00'} : {}">{{ i.delta1m }}</td>
        <!-- td style="background-color:#F5FAFF">{{ i.down10}}</td>
        <td style="background-color:#E0F0FF">{{ i.distance < calculator.parallax && " " || i.down20}}</td>
        <td style="background-color:#B8DBFF">{{ i.distance < calculator.parallax && " " || i.down30}}</td>
        <td>{{i.distance}}m</td>
        <td style="background-color:#A3D1FF">{{ i.distance < calculator.parallax && " " || i.down40}}</td>
        <td style="background-color:#DDDDFF">{{ i.distance < calculator.parallax && " " || i.down50}}</td -->
        <td ng-show="showDrop" style="background-color:#FFF">{{i.time}}</td>
        <td ng-show="showDrop" style="background-color:#FFF">{{i.drop}}</td>
        <td ng-show="showDrop" style="background-color:#FFF">{{i.deltaScope}}</td>
      </tr>
      <tr class="tdcontrols do-not-print">
        <th>Save</th>
        <td colspan="99"><button ng-click="saveSettings()">local save</button></td>
      </tr>
      <tr class="tdcontrols do-not-print">
        <th>Bookmark</th>
        <td colspan="99"><a href="index.html#!/sight/{{ inputsURI }}" target="_blank">{{ inputs.settingsName }}</a></td>
      </tr>
      <tr class="do-not-print">
        <td colspan="6" class="storage-warning">iOS and Android may discard this local data occasionally! Make a bookmark or a screenshot.</td>
      </tr>
      </table>
      
      
      <br/>
      <table>
      <tr>
        <th colspan="6"><input type="text" ng-model="parcour.key" style="width:200px; text-align:center;"></th>
      </tr>
      <tr>
        <th>Target<!--button style="float:right" ng-click="calculator.addTarget(0)">+</button--></th>
        <th>sight</th>
        <th>dist.</th>
        <th>&deg;angle</th>
        <th>LofS</th>
      </tr>
      <tr ng-repeat="target in parcour.object" >
        <td><input type="text" ng-model="target.id" placeholder="1 Eagle" style="width:65px"><button class="do-not-print" ng-click="calculator.addRemoveTarget($index)">{{ target.id ? "+" : "-" }}</button></td>
        <td>{{ calculator.evalSpline(target.d).toFixed(2) }}</td>
        <td><input type="number" ng-model="target.d" placeholder="distance" style="width:50px"></td>
        <td><input type="number" ng-model="target.a" placeholder="angle (+/-)" style="width:50px"></td>
        <td>{{ (target.d / Math.cos(target.a * Math.PI/180.0)).toFixed(2) }}</td>
      </tr>
      <tr class="tdcontrols do-not-print">
        <th>Save</th>
        <td colspan="99"><button ng-click="calculator.storeParcour()">local save</button></td>
      </tr>
      <tr class="do-not-print">
        <td colspan="6" class="storage-warning">iOS and Android may discard this local data occasionally! Bookmark the current parcour or make a screenshot!</td>
      </tr>
      <tr class="tdcontrols do-not-print">
        <th>Bookmark</th>
        <td colspan="99"><a href="index.html#!{{ parcourURI }}" target="_blank">{{ parcour.key }}</a></td>
      </tr>
      <tr class="do-not-print" ng-repeat="(key, parcour) in parcourStore">
        <td  colspan="3">{{ key }}</td>
        <td><button ng-click="calculator.restoreParcour(key)">load</button></td>
        <td><button ng-click="calculator.deleteParcour(key)">delete</button></td>
      </tr>
      </table>
      <br/>

      
      <br/>
      <table class="do-not-print">
      <tr>
        <th>old reading</th>
        <td><input type="number" ng-model="calculator.transformScaleFrom" placeholder="23.3" style="width:50px"></td>
      </tr>
      <tr>
        <th>new reading</th>
        <td><input type="number" ng-model="calculator.transformScaleTo" placeholder="23.1" style="width:50px"></td>
      </tr>
      <tr>
        <td><button ng-click="calculator.transformScale()">shift scale</button></td>
      </tr>
      </table>
      <br/>
            
      
      <table id="readings" class="do-not-print">
      <tr>
        <th>Saved reading</th>
        <th>Use</th>
      </tr>
      <tr ng-repeat="(key, value) in savedSettings">
        <td><a href="" ng-click="showSavedReadingsExpanded=!showSavedReadingsExpanded">{{ key }}</a></td>
        <td><button ng-click="loadSettings(key)">load</button></td>
        <td ng-if="showSavedReadingsExpanded" ng-repeat="item in savedSettings[key]"> {{ item.distance }}m {{ item.reading }} </td>
        <td ng-if="showSavedReadingsExpanded"><button ng-click="deleteSettings(key)">delete</button></td>
      </tr>
      <tr>
        <td colspan="6" class="storage-warning">iOS and Android may discard this local data occasionally! Make a bookmark or a screenshot.</td>
      </tr>
      </table>
      <br/>
      
      
  <table class="do-not-print">
  <tr>
      <th style="width:360px;"><a href="" ng-click="showHelp=!showHelp">Instructions</a></th>
  </tr>
  <tr ng-show="showHelp">
      <td class="helptext-td">
          <p>Enter 3 readings to start: 20m, 30m, 50m. If you have more than 3 values you can use "Show Polyfit" to find 
          bad readings (outliers) that are to high (orange) or low (blue). This will do a 2nd order polynomial fit from 20m to max.
          You can enter yard-readings even if it says meters, just do not mix y and m. Drop does not consider drag.
          </p>
          <p>If you need parallax readings for 3D, shoot at least 3 distances between 15 and 4m. 
          In the parallax-region optical parallax-error, which is function of the straight-line distance to target, outweights the 
          arrow-drop, so fill in these readings carefully. A separate interpolation will deal with the values.
          There is no way to find correct values for e.g. 60 degree uphill/downhill shots at 10m straight line distance, 
          which is 5m arrow-drop distance and 10m parallax distance. A table cannot capture that.
          </p>
      <p>Browser vendors decided to make local storage different between HTTP and HTTPS (secure) versions of the page!
      Google announced to disable local storage on insecure origins (non HTTPS). This is very stupid in our case.</p>
      <p>Howto bookmark: (1) open/click the link "Bookmark" above to open in default webbrowser, (2) create bookmark on phone or desktop, (3) repeat after changes!</p>
      <p>CLEAR ALL SAVED DATA INSTANTLY: <button ng-click="clearLocalStorage()">CLEAR</button></p>
      </td>
   </tr>
   </table>
    </div>

    <!-- Advanced Stuff Desktop ... -->
    <center>
        <br/>
        <a href="" ng-click="showScaleAndSVG=!showScaleAndSVG">Show Scope Graphs</a>
        <br/>
    </center>
    <div ng-if="showScaleAndSVG">
        <br/>
        <div id="shotSVG" style="margin:auto; width:210mm; height:200mm; border:1px solid black;">
        </div>
        <br/>
        <center>
            <button ng-click="calculator.drawSvgShot(0)">Draw Scope Readings</button>
            <button ng-click="calculator.drawSvgShot(1)">Draw Shot</button>
            X = Distance 0-70m Y = Arrow drop, Scope reading
        </center>
        <h3>Sureloc Scale</h3>
        <div id="scale" style="width:100mm; height:11mm; border:1px solid black;"></div>
        <pre id="svgxml"></pre>
        <button ng-click="calculator.calcSvgModel()">Fine adjust svg SCALE for printing (0.8 ... 1.5)</button>
        <input type="number" min="0.8" max="1.5" step="0.002" ng-model="inputs.svgScaleX" style="width:50px">
        <button ng-click="calculator.saveSvg()">SAVE TO FILE</button>
        <br/>
        <pre>
            1. copy SVG into a file arrow.svg: <button ng-click="calculator.saveSvg()">SAVE TO FILE</button>
            2. open arrow.svg in Crome or Safari and print it.
            3. (fine adjust scale and print final version, if needed)   
        </pre>
            

    </div>
   
</body>
</html>
