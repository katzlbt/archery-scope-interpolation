<html manifest="cache.manifest" ng-app="myApp" content="text/html;charset=UTF-8">
<head>
    <title>Archery Scope Interpolation</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link href='kghostview.png' rel='apple-touch-icon' type='image/png'>
    <script src="svg.min.js"> </script>
    <script src="FileSaver.min.js"> </script>
    <script src="angular.min.js"></script>
    <script src="numeric-1.2.6.js"></script>
    <style type="">
    .tdslope { width:250px }
    table { margin:auto; font-family:monospace; border-width:1px; border-collapse: collapse; border-style: solid; }
    td, th { min-width:50px; border-width:1px; border-style: solid; text-align:center; }
    .tdcontrols { height:36px }
    .parallax { background-color: #CCC; }
    .parallax-wrong { text-decoration: line-through; }
    .tenmeters { background-color: #FCC; font-weight: bold }
    .twometers { background-color: #FFC; }
    .storage-warning { max-width:260px; font-family:Helvetica; font-size:0.7rem; }
    .helptext-td { max-width:360px; font-family:Helvetica; font-size:0.7rem; text-align: left; }
    
    .polyfit-color-high { background-color:#FF5E23 }
    .polyfit-color-low { background-color:#237BFF }
    
    .parcour-highlight-tr { background-color:#FFCC33 }

    
    /* disrupts jEdit syntax coloring */ 
    @media screen
    {
        .parcour-tr:nth-child(even) { background-color:#DDDDDD }
    }
    
    @media print 
    { 
        .parcour-tr:nth-child(even) { background-color:#DDDDDD }
        
        table { page-break-after:always; }
        tr    { page-break-inside:avoid; page-break-after:auto }
        input, button { border-width:0px; border:none; }
        .do-not-print { display:none; }
    }
    </style>
<script>

    var app = angular.module('myApp', []);
    app.config(['$controllerProvider', function($controllerProvider) {
      // this option might be handy for migrating old apps, but please don't use it in new ones!
      $controllerProvider.allowGlobals();
    }]);

    function getParameterByName(name) { // GET parameter ?data=
    name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
    var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
        results = regex.exec(location.search);
    return results == null ? "" : results[1];
}

var isInWebAppiOS = (window.navigator.standalone == true);
var isInWebAppChrome = (window.matchMedia('(display-mode: standalone)').matches);

function getHashbangParameter(parameterName,defaultValue)
    { 
        if(parameterName instanceof Array)
        {
            for(var i in parameterName)
            {
                var ret = this.getHashbangParameter(parameterName[i], null);
                if(ret !== null)
                    return ret;
            }
            
            return defaultValue;
        }
        
        defaultValue = defaultValue || null;
        if( !parameterName )
            throw new Error("getHashbangParameter: 'parameterName' is missing!");

        // parameter schema: "/paramName/:paramValue/" 
        var regex = new RegExp("/"+parameterName+"/([^/#&]+)"); // [A-Za-z0-9_%]
        var match = window.location.href.match(regex);
        return match ? match[1] : defaultValue;
    };

function calculateIntegerHashFromString(s)
    {
        if(!s)
            return 0;
            
        return s.split("").reduce(function(a,b){a=((a<<5)-a)+b.charCodeAt(0);return a&a},0);              
    }
        


    // http://blog.ivank.net/interpolation-with-cubic-splines.html
	function CSPL()
	{
	    this.xs = [];
	    this.ys = [];
	    this.ks = [];
	}
	
	CSPL._gaussJ = {};
	CSPL._gaussJ.solve = function(A, x)	// in Matrix, out solutions
	{
		var m = A.length;
		for(var k=0; k<m; k++)	// column
		{
			// pivot for column
			var i_max = 0; var vali = Number.NEGATIVE_INFINITY;
			for(var i=k; i<m; i++) if(A[i][k]>vali) { i_max = i; vali = A[i][k];}
			CSPL._gaussJ.swapRows(A, k, i_max);
			
			if(A[i_max][i] == 0) console.log("matrix is singular!");
			
			// for all rows below pivot
			for(var i=k+1; i<m; i++)
			{
				for(var j=k+1; j<m+1; j++)
					A[i][j] = A[i][j] - A[k][j] * (A[i][k] / A[k][k]);
				A[i][k] = 0;
			}
		}
		
		for(var i=m-1; i>=0; i--)	// rows = columns
		{
			var v = A[i][m] / A[i][i];
			x[i] = v;
			for(var j=i-1; j>=0; j--)	// rows
			{
				A[j][m] -= A[j][i] * v;
				A[j][i] = 0;
			}
		}
	}
	
	CSPL._gaussJ.zerosMat = function(r,c) {var A = []; for(var i=0; i<r; i++) {A.push([]); for(var j=0; j<c; j++) A[i].push(0);} return A;}
	CSPL._gaussJ.printMat = function(A){ for(var i=0; i<A.length; i++) console.log(A[i]); }
	CSPL._gaussJ.swapRows = function(m, k, l) {var p = m[k]; m[k] = m[l]; m[l] = p;}
		
	CSPL.prototype.getNaturalKs = function(xs, ys)	// in x values, in y values, out k values
	{
	    this.xs = xs;
	    this.ys = ys;
	    CSPL._getNaturalKs(xs, ys, this.ks);
	};
	
	CSPL._getNaturalKs = function(xs, ys, ks)	// in x values, in y values, out k values
	{
		var n = xs.length-1;
		var A = CSPL._gaussJ.zerosMat(n+1, n+2);
			
		for(var i=1; i<n; i++)	// rows
		{
			A[i][i-1] = 1/(xs[i] - xs[i-1]);
			
			A[i][i  ] = 2 * (1/(xs[i] - xs[i-1]) + 1/(xs[i+1] - xs[i])) ;
			
			A[i][i+1] = 1/(xs[i+1] - xs[i]);
			
			A[i][n+1] = 3*( (ys[i]-ys[i-1])/((xs[i] - xs[i-1])*(xs[i] - xs[i-1]))  +  (ys[i+1]-ys[i])/ ((xs[i+1] - xs[i])*(xs[i+1] - xs[i])) );
		}
		
		A[0][0  ] = 2/(xs[1] - xs[0]);
		A[0][1  ] = 1/(xs[1] - xs[0]);
		A[0][n+1] = 3 * (ys[1] - ys[0]) / ((xs[1]-xs[0])*(xs[1]-xs[0]));
		
		A[n][n-1] = 1/(xs[n] - xs[n-1]);
		A[n][n  ] = 2/(xs[n] - xs[n-1]);
		A[n][n+1] = 3 * (ys[n] - ys[n-1]) / ((xs[n]-xs[n-1])*(xs[n]-xs[n-1]));
			
		CSPL._gaussJ.solve(A, ks);		
	};
		
	CSPL.prototype.evalSpline = function(x)
	{
	    return CSPL._evalSpline(x, this.xs, this.ys, this.ks);
	};
	
	CSPL._evalSpline = function(x, xs, ys, ks)
	{
		var i = 1;
		while(xs[i]<x) // breaks beyond array undefined < any
		    i++;
		
		// extrapolate far
		if(i == xs.length)
		    i--;
		    
		var t = (x - xs[i-1]) / (xs[i] - xs[i-1]);
		
		var a =  ks[i-1]*(xs[i]-xs[i-1]) - (ys[i]-ys[i-1]);
		var b = -ks[i  ]*(xs[i]-xs[i-1]) + (ys[i]-ys[i-1]);
		
		var q = (1-t)*ys[i-1] + t*ys[i] + t*(1-t)*(a*(1-t)+b*t);
		return q;
	};

	function polynomialCurveFitting(xArray, yArray)
	{
        order = 2;
        
        var xMatrix = [];
        var xTemp = [];
        var yMatrix = numeric.transpose([yArray]);
        
        for (j=0;j<xArray.length;j++)
        {
            xTemp = [];
            for(i=0;i<=order;i++)
            {
                xTemp.push(1*Math.pow(xArray[j],i));
            }
            xMatrix.push(xTemp);
        }
        
        var xMatrixT = numeric.transpose(xMatrix);
        var dot1 = numeric.dot(xMatrixT,xMatrix);
        var dotInv = numeric.inv(dot1);
        var dot2 = numeric.dot(xMatrixT,yMatrix);
        var solution = numeric.dot(dotInv,dot2);
        //console.log("Coefficients a + bx^1 + cx^2...");
        //console.log(solution);
        return solution;
    };

function LocalStorageManager(localStorageId, scope, objectKey, dbKey, defaultId, defaultObject)
{
    // maintains localStorageId_current and localStorageId_DB
    
    this.localStorageId = localStorageId;
    this.scope = scope;
    this.objectKey = objectKey;
    this.dbKey = dbKey;
    
    this.scope[this.objectKey] = {};
    this.scope[this.objectKey]['key'] = defaultId;
    this.scope[this.objectKey]['object'] = defaultObject;
    this.scope[this.dbKey] = {};  // always { id1:object1, id2:object2, ... }
    
    this.load();
    this.restore(null);
}

LocalStorageManager.prototype._currentToJSON = function() // save the current Item temporarily in LS
    {
        return angular.toJson([this.scope[this.objectKey]['key'], this.scope[this.objectKey]['object']]);
    }
    
LocalStorageManager.prototype._currentFromJSON = function(current) // save the current Item temporarily in LS
    {
        if(current[0])
        {
            this.scope[this.objectKey]['key'] = current[0];
            this.scope[this.objectKey]['object'] = current[1];
        }
    };
    
LocalStorageManager.prototype.currentToURIComponent = function() // save the current Item temporarily in LS
    {
        var c = this._currentToJSON();
        c = c.replace(/[^\x00-\xFF]/g, ""); // remove non ASCII components that cause exceptions in btoa
        return btoa ? encodeURIComponent(btoa(c)) : "ERROR_btoa_not_supported";
    };
    
LocalStorageManager.prototype.currentFromURIComponent = function(uric) // save the current Item temporarily in LS
    {
        var b64 = decodeURIComponent(uric);
    
        try
        {
            var json = atob(b64);
            this._currentFromJSON(this._fromJSONcatch(json));
            return true;
        }
        catch(e) 
        {
            console.log("Cannot decode! The data is invalid.");
        }
        
        return false;
    };

LocalStorageManager.prototype.save = function() // save the current Item temporarily in LS
    {
        localStorage.setItem(this.localStorageId + "_current", this._currentToJSON());
        //console.log("LS SAVE", this.scope[this.objectKey]['key']);
    };

LocalStorageManager.prototype.load = function(id) // load current item os startup
    {
        var current = this._getItemAndDecode(this.localStorageId + "_current",[null, null]);
        this._currentFromJSON(current);
    };

LocalStorageManager.prototype.store = function() // save the current Item in LS DB
    {
        this.scope[this.dbKey] = this._getItemAndDecode(this.localStorageId + "_DB", {});
        this.scope[this.dbKey][this.scope[this.objectKey]['key']] = this.scope[this.objectKey]['object'];
        localStorage.setItem(this.localStorageId + "_DB", angular.toJson(this.scope[this.dbKey]));
    };

LocalStorageManager.prototype.delete = function(idKey) // save the current Item in LS DB
    {
        this.scope[this.dbKey] = this._getItemAndDecode(this.localStorageId + "_DB", {});
        delete this.scope[this.dbKey][idKey];
        localStorage.setItem(this.localStorageId + "_DB", angular.toJson(this.scope[this.dbKey]));
    };

LocalStorageManager.prototype.restore = function(idOrNull) // save the current Item in LS DB
    {
        this.scope[this.dbKey] = this._getItemAndDecode(this.localStorageId + "_DB", {});
        
        if(!idOrNull)
            return;
            
        var obj = this.scope[this.dbKey][idOrNull];
        if(obj)
        {
            this.scope[this.objectKey]['key'] = idOrNull;
            this.scope[this.objectKey]['object'] = obj;
        }
    };

LocalStorageManager.prototype._getItemAndDecode = function(id, _default) // save the current Item in LS DB
    {
        var str = localStorage.getItem(id);
        
        if(!str)
            return _default;
            
        return this._fromJSONcatch(str, _default);
    };
    
LocalStorageManager.prototype._fromJSONcatch = function(jsonString, _default) // save the current Item in LS DB
    {
        try
        {
            return angular.fromJson(jsonString);
        }
        catch(e) 
        {
            console.log("JSON PARSE ERROR");
        }
        
        return _default;
    };

function Calculator($rootScope, $timeout)
{
    this.scope = $rootScope;
    DEBUG_SCOPE = $rootScope;    
    
    this.scope.Math = window.Math; // we need Math in the template
    
    this.scope.inputs = { 
        arrow:{ grains:400, name:"Arrow One", v0fps:245, v0:74 },
        settings:[], // [{ distance:, reading: }, ...]
        maxDistance:60,
        svgScaleX:1.0
        };
    
    this.scope.savedSettings = {};  // database { "settings-name": object, }

    var me = this;
    
    this.scope.parcour = null; // {key:, value:} Array of target objects { id:"1 Adler", d:10.5, a:-25 }, ...        
    this.scope.parcourStore = null; // Array of target objects { id:"1 Adler", d:10.5, a:-25 }, ...        
    this.localStorageParcour = new LocalStorageManager("ARCHISCOPE_parcour", this.scope, "parcour", "parcourStore", "WBSC Rot", [{ id:"1 Dachs", d:23, a:-11 }, { id:"2 Fuchs", d:24, a:-16 }]);
    
    //this.scope.$watch("inputs.arrow.weightAll", function(){ me.scope.inputs.arrow.grams = me.scope.inputs.arrow.weightAll/me.scope.inputs.arrow.count; });
    //this.scope.$watch("inputs.arrow.count", function(){ me.scope.inputs.arrow.grams = me.scope.inputs.arrow.weightAll/me.scope.inputs.arrow.count; });
    //this.scope.$watch("inputs.arrow.grams", function(){ me.scope.inputs.arrow.grains = me.scope.inputs.arrow.grams * 15.432358; });
    
    this.maxTable = 90;
    
    this.parallax = 16; // meters
    
    this.cubicSpline = null; // interpolator for 16+ meters
    this.cubicSplineBunnyshot = null; // interpolator for few meters
        
    this.load();
    this._calculateUris();
        
    this.scope.clearLocalStorage = function() { me.clear(); };
    this.scope.saveSettings = function() { me.saveSettings(); };
    this.scope.loadSettings = function(x) { me.loadSettings(x); };
    this.scope.deleteSettings = function(x) { if(confirm('Delete?')) { me.deleteSettings(x); } };
        
    this.scope.showScaleAndSVG = false; // disables calcSvgModel()
    this.scope.$watch("inputs.svgScaleX", function(){ me.calcSvgModel(); });
        
    this.scope.calculator = this;
    
    var ls = localStorage.getItem('ARCHISCOPE_parcour_highlight');
    this.parcourHighlightRow = ls ? parseInt(ls) : 0;  // see also startWatches!
        
    $timeout(function(){ me.startWatches(); },1);
    
    $timeout(function(){ 
        if(me.parcourHighlightRow > 0)
        {
            var element = document.getElementById("parcourTable")
            var tdarray = element.getElementsByTagName("td");
            var td = tdarray[me.parcourHighlightRow];
            td.scrollIntoView(true);
        }
    },1000);    
}

Calculator.prototype.startWatches = function()
{
    var me = this;
    
    this.scope.$watch("inputs.arrow.name", function(){
        if(!me.scope.inputs.arrow)
            me.scope.inputs["arrow"] = {};
        if(!me.scope.inputs.arrow.name)
            me.scope.inputs.arrow.name = "A1";
            
        me.scope.currentSettingsName = me.scope.inputs.arrow.name + " " + (new Date()).toISOString().substring(2,10); });
        
    this.scope.$watch("inputs.arrow.v0fps", function(){
        if(!me.scope.inputs.arrow)
            me.scope.inputs["arrow"] = {};
        if(!me.scope.inputs.arrow.v0fps)
            me.scope.inputs.arrow.v0fps = 265;
            
        me.scope.inputs.arrow.v0 = Math.round(me.scope.inputs.arrow.v0fps * 0.3048);
        me.calcTable(); });
        
    this.scope.$watch("inputs.maxDistance", function(){ me.calcModel(); });

    this.scope.$watch("model", function(){ me.calcTable(); }, true);  // sets inputs.settings
    
    this.scope.$watch("inputs", function(n,o){
        //console.log("inputs changed!", o, n);
        document.title = me.scope.currentSettingsName; 
        me.scope.inputsJSON = angular.toJson(me.scope.inputs);
        me.save(); }, true);
        
    this.scope.$watch("parcour", function(){ me.localStorageParcour.save(); me.updateUrlParameter("parcour"); }, true);
    
    me.calcModel();
    me.calcTable();
};

Calculator.prototype.setExpandedModelDistance = function(d)
{
    var d = Math.floor(d/2)*2;
    if(d == this.expandedModelDistance)
        this.expandedModelDistance = 0;
    else
        this.expandedModelDistance = d;
}

Calculator.prototype.getUrlParameter = function() // return json as string
{
    var data = null;
    // 1. check the hashbang parameter #!/scope/{encodedData}
    data = getHashbangParameter("sight",null);
    
    // 2. else check the GET ?data= parameter for backwards compatibility
    if(!data)  // we have the GET parameter ?data=
        data = getParameterByName("data");
        
    if(!data)
        return null;
        
    // 3. decode the data
    data = decodeURIComponent(data);
    
    try
    {
        data = atob(data);
    }
    catch(e) 
    {
        alert("Passed scope readings cannot be decoded! The data is invalid.");
        return null;
    }
    
    return data; // return json as string
};

Calculator.prototype._calculateUris = function() // renew the hashbang parameter
{
    this.scope.inputsURI =  "/sight/" + (btoa ? encodeURIComponent(btoa(this.scope.inputsJSON)) : "ERROR_btoa_not_supported");    
    this.scope._dataParamHash = calculateIntegerHashFromString(this.scope.inputsJSON); // json string of this.scope.inputsJSON
    
    if(getParameterByName("data")) // strip the old get parameter
        window.history.replaceState(null, null, window.location.pathname);

    this.scope.parcourURI = "/parcour/" + this.localStorageParcour.currentToURIComponent();
};

Calculator.prototype.updateUrlParameter = function(source) // renew the hashbang parameter
{
    this._calculateUris();
    
    document.title = this.scope.currentSettingsName; 
    
    if(getParameterByName("data")) // strip the old get parameter
        window.history.replaceState(null, null, window.location.pathname);

    window.location.hash = "!" + this.scope.inputsURI + this.scope.parcourURI;    

    console.log("SET #!", this.scope.inputsURI.length, this.scope.parcourURI.length, source)
};

Calculator.prototype.load = function()
{
    var ls = localStorage.getItem('ARCHISCOPE_savedSettings'); // the database of arrows
    if(ls)
    {
        try
        {
            this.scope.savedSettings = angular.fromJson(ls);
        }
        catch(e) 
        {
            console.log("ARCHISCOPE_savedSettings JSON PARSE ERROR");
        }
    }
        
    var inp = localStorage.getItem('ARCHISCOPE_scopeinputs'); // the CURRNT arrow
    if(inp)
    {
        try
        {
            this.scope.inputs = angular.fromJson(inp);
            
            if(this.scope.inputs.v0) // versioning
                this.scope.inputs.arrow.v0 = this.scope.inputs.v0;
            if(this.scope.inputs.v0fps) // versioning
                this.scope.inputs.arrow.v0fps = this.scope.inputs.v0fps;
            
            this.scope.inputsJSON = inp;
            this.scope._dataParamHash = calculateIntegerHashFromString(inp); // json this.scope.inputsJSON 
        }
        catch(e) 
        {
            console.log("ARCHISCOPE_scopeinputs JSON PARSE ERROR");
        }        
    }

    if(inp && (isInWebAppiOS || isInWebAppChrome)) // restore from URL only if localStorage was wiped
        return;

    /* not reachable in standalone web app if ARCHISCOPE_scopeinputs localStorage is set
    Web apps always ask to restore from URL parameter each time they are started, otherwise.
    */

    var data = this.getUrlParameter();  // return json as string
    var saveAll = false;
    if(data)  // we have the /sight/ parameter or ?data=
    {
        // avoid confirm on every opening of page, only if data= is new
        var hash = calculateIntegerHashFromString(data);
        if(hash != this.scope._dataParamHash)
        {
            if(confirm("Replace SCOPE data from URL?") === true)
            {
                this.scope.inputs = angular.fromJson(data);
                this.scope._dataParamHash = hash;
                // this.save(); // overwrites URL /parcour/!
                saveAll = true;
            }
        }
    }
    
    var parcour = getHashbangParameter("parcour", null);
    if(parcour)
    {
        var hashURIC = calculateIntegerHashFromString(parcour);
        var hashCurrent = calculateIntegerHashFromString(this.localStorageParcour.currentToURIComponent());
        if(hashURIC != hashCurrent)
        {
            if(confirm("Replace PARCOURS from URL?") === true)
            {
                this.localStorageParcour.currentFromURIComponent(parcour);
                saveAll = true;
            }
        }    
    }
    
    if(saveAll)
        this.save();
    
    // not reachable in standalone web app
};

Calculator.prototype.save = function() // this is the instant save function
{
    this.scope.inputsJSON = angular.toJson(this.scope.inputs);
    this.updateUrlParameter("save");
    
    localStorage.setItem('ARCHISCOPE_scopeinputs', this.scope.inputsJSON);
    
    var json = angular.toJson(this.scope.savedSettings);
    localStorage.setItem('ARCHISCOPE_savedSettings', json);
    
    this.localStorageParcour.save();
};

Calculator.prototype.clear = function()
{
    // localStorage.clear(); removes all site settings, scoresheets, etc.
    
    localStorage.removeItem('ARCHISCOPE_scopeinputs');
    localStorage.removeItem('ARCHISCOPE_savedSettings');
    localStorage.removeItem('ARCHISCOPE_parcour');
    localStorage.removeItem('ARCHISCOPE_parcour_highlight');
    
    window.location.search="?reload=1";
};

Calculator.prototype.saveSettings = function()
{
    if(!this.scope.currentSettingsName) // undefined or empty
    {
        alert("Name of scope readings is empty! Cannot save.");
        return;
    }
    
    this.scope.savedSettings[this.scope.currentSettingsName] = this.scope.inputs;
    this.save();
};

Calculator.prototype.loadSettings = function(name)
{
    if(this.scope.savedSettings[name] instanceof Array) // old version does not store arrow in settings
        this.scope.inputs.settings = this.scope.savedSettings[name];
    else
        this.scope.inputs = this.scope.savedSettings[name];
    
    this.scope.currentSettingsName = name; // me.scope.inputs.arrow.name+Date
    this.calcModel();
};

Calculator.prototype.deleteSettings = function(name)
{
    delete this.scope.savedSettings[name];
    this.save();
};

Calculator.prototype.calcModel = function()  // create the distance model; does not change when inputs are changed, see calcTable()
{
    this.scope.model = [];
    
    var max = Math.min(Math.max(30,this.scope.inputs.maxDistance), 120);
    
    for(var j=0; j<this.scope.inputs.settings.length; j++) // do not discard user data
        if(this.scope.inputs.settings[j].distance > max)
            max = this.scope.inputs.settings[j].distance;
                    
    var i=0, step=1;
    for(var d = 4; d <= max; d+=step) // d is the distance to the target           
    {
        if(d>=this.expandedModelDistance && d<this.expandedModelDistance+2)
            step = 0.25;
        else
        if(d>11) // above 11m switch to 2
            step = 2;
        else
            step = 1;
            
        
        if(typeof(this.scope.inputs.maxDistance) == "number" && d > max)
            break;
            
        this.scope.model[i] = {};
        
        this.scope.model[i].distance = d;
        this.scope.model[i].reading = 0;
        
        for(var j=0; j<this.scope.inputs.settings.length; j++)
            if(this.scope.inputs.settings[j].distance == d)
                this.scope.model[i].reading = this.scope.inputs.settings[j].reading; 
                
        i++;
    }
};

Calculator.prototype.calcTable = function() // copies distance/sight-reading to inputs
{
    var settingsChanged = false, n = 0;
    var newSettings = [];
    
    var xs0=[], ys0=[], x0n = 0;  // cubic spline
    var xs=[], ys=[], xn = 0;  // cubic spline
    
    xs0[x0n] = 0;
    ys0[x0n] = 80;
    x0n++;
    
    for(var i = 0; i < this.scope.model.length; i++)
    {
        if(this.scope.model[i].reading > 0)  // COPY READING TO SETTINGS!
        {
            if(this.scope.inputs.settings[n] == undefined ||
               this.scope.inputs.settings[n].distance != this.scope.model[i].distance || 
               this.scope.inputs.settings[n].reading != this.scope.model[i].reading) // avoid firing $watch if no change took place
            {
                settingsChanged = true;
            }
            
            newSettings.push({ distance:this.scope.model[i].distance, reading:this.scope.model[i].reading });
            n++;
            
            if(this.scope.model[i].distance < this.parallax) // must avoid paralax error!!
            {
                xs0[x0n] = this.scope.model[i].distance;
                ys0[x0n] = this.scope.model[i].reading;
                x0n++;
            }
            else
            {
                xs[xn] = this.scope.model[i].distance;
                ys[xn] = this.scope.model[i].reading;
                xn++;
            }
        }
    }

    if(settingsChanged || this.scope.inputs.settings.length != newSettings.length)
    {
        this.scope.inputs.settings = newSettings;
        console.log("inputs.settings = newSettings");
    }
    
    if(n < 3)
        return;
    
    if(xn >= 3) // more than 3 values > this.parallax
    {
        this.cubicSpline = new CSPL();
        this.cubicSpline.getNaturalKs(xs, ys);
        this.calcPolyfit();
    }
    else
        this.cubicSpline = null;
    
    
    if(x0n >= 3) // more than 3 values < this.parallax
    {
        // Join the splines ...
        if(this.cubicSpline)
        {
            xs0[x0n] = this.parallax;
            ys0[x0n] = this.cubicSpline.evalSpline(this.parallax);;
            x0n++;
        }
        
        this.cubicSplineBunnyshot = new CSPL();
        this.cubicSplineBunnyshot.getNaturalKs(xs0, ys0);
    }
    else
        this.cubicSplineBunnyshot = null;
    
    for(var i = 0; i < this.scope.model.length; i++)
    {
        this.scope.model[i].polyfit = this.evalPolyfit(this.scope.model[i].distance);
        
        var y = this.evalSpline(this.scope.model[i].distance);
        this.scope.model[i].interpolated = y.toFixed(2); // WARNING this is a String!
        var y2 = this.evalSpline(this.scope.model[i].distance+1);
        this.scope.model[i].delta1m = (y2-y).toFixed(2); // WARNING this is a String!
        if(i>0) // 2nd derivative of change
            this.scope.model[i].delta2nd= (this.scope.model[i].delta1m - this.scope.model[i-1].delta1m).toFixed(2); // WARNING this is a String!
    }
            
    this.calcSlope();
};

Calculator.prototype.evalSpline = function(distance) // handle parallax
{
    if(distance < this.parallax)
    {
        if(this.cubicSplineBunnyshot)
            return this.cubicSplineBunnyshot.evalSpline(distance);
        
        return 0;
    }
    
    if(this.cubicSpline)
        return this.cubicSpline.evalSpline(distance);
        
    return 0;
}

Calculator.prototype.calcPolyfit = function()
{
    var xMeters = [];
    var yReadings = [];
    
    for(var j=0; j<this.scope.inputs.settings.length; j++)
    {
        if(this.scope.inputs.settings[j].distance < 22)
            continue;
            
        xMeters.push(this.scope.inputs.settings[j].distance);
        yReadings.push(this.scope.inputs.settings[j].reading);
        // console.log(this.scope.inputs.settings[j].distance + "," + this.scope.inputs.settings[j].reading);
    }
    
    if(xMeters.length >= 2)
        this.polynomial = polynomialCurveFitting(xMeters, yReadings);
    else
        this.polynomial = null;
};

Calculator.prototype.evalPolyfit = function(xMeters)
{
    if(xMeters < 22 || !this.polynomial)
        return NaN;
    // var xMeters = model.distance;
    var r = this.polynomial[0][0] + this.polynomial[1][0] * xMeters + this.polynomial[2][0] * xMeters * xMeters;
    return Math.round(r*100)/100;
};

Calculator.prototype.calcSlope = function()
{
    var d2r = Math.PI/180; // deg to rad
    
    for(var i = 0; i < this.scope.model.length; i++)
    {
        var d = this.scope.model[i].distance;
        var cd;
        cd = Math.cos(10*d2r) * d; this.scope.model[i].down10 = cd.toFixed(1); // CSPL.evalSpline(cd, xs, ys, ks).toFixed(2);
        cd = Math.cos(20*d2r) * d; this.scope.model[i].down20 = cd.toFixed(1); // CSPL.evalSpline(cd, xs, ys, ks).toFixed(2);
        cd = Math.cos(30*d2r) * d; this.scope.model[i].down30 = cd.toFixed(1); // CSPL.evalSpline(cd, xs, ys, ks).toFixed(2);
        cd = Math.cos(40*d2r) * d; this.scope.model[i].down40 = cd.toFixed(1); // CSPL.evalSpline(cd, xs, ys, ks).toFixed(2);
        cd = Math.cos(50*d2r) * d; this.scope.model[i].down50 = cd.toFixed(1); // CSPL.evalSpline(cd, xs, ys, ks).toFixed(2);
        
        var time = d/this.scope.inputs.arrow.v0;
        var drop = 9.81/2.0*time*time*100;
        this.scope.model[i].time = time.toFixed(2);
        this.scope.model[i].drop = drop.toFixed(0); // excludes drag / air resistance
        
        var t1 = (d-1)/this.scope.inputs.arrow.v0;
        var d1 = 9.81/2.0*t1*t1*100; // *100 cm
        this.scope.model[i].deltaScope = Math.round((drop-d1)/this.scope.model[i].delta1m);  // 1 REV on scope is x cm on target 
    }
};

Calculator.prototype.calcSvgModel = function(sight)
{
    if(false == this.scope.showScaleAndSVG) // hidden
        return;        
        
    if(sight)
        this._calcSvgModelSigthType = sight;
    
    var mmPerRevolution = 0.99234;
    var minLine = 6 * mmPerRevolution; // in mm for surelock
    var maxLine = 88 * mmPerRevolution;
    var textOffsetX = 55;
    var textOffsetY = 0;
    var textLinebreak = 4;
    var angles = [10,15,20,25,30,40,50];
    var anglesOffsets = {0:10, 10:8, 15:7, 20:6, 25:5, 30:4, 40:2, 50:0}; // 10-(m.angle)/5

    switch(this._calcSvgModelSigthType)
    {
        case "shibuya":
            mmPerRevolution = 1/24*25.4;
            minLine = 0; // in mm
            maxLine = 111.125; // 105.8333333333 at 10 111.125 = 10.5 * mmPerRevolution
            textOffsetX = 1;
            textOffsetY = 4.88;
            textLinebreak = 5;
            angles = [10,20,30,40];
            anglesOffsets = {0:10, 10:8, 20:7, 30:6, 40:5};
            break;
    }
    
    if(!this.sightTextOffsetX)
        this.sightTextOffsetX = textOffsetX; // init template
    else
        textOffsetX = this.sightTextOffsetX; // copy from template
        
    if(!this.sightTextOffsetY)
        this.sightTextOffsetY = textOffsetY;
    else
        textOffsetY = this.sightTextOffsetY;
    
    this.svgModel = [];
    
    var me = this;
    var calcOneAngle = function(a, model)
    {
        var minReading = 999;
        var minDistance = 999;
        for(var d=70; d>=10; d-=2) // parallax error prohibits plotting 5m values
        {
            var p = { distance:d , reading:0, angle:a };
            var realD = p.distance * Math.cos(a * d2r);
            p.reading = me.evalSpline(realD) * mmPerRevolution; // reading is actually mm from left side
            
            minReading = Math.min(minReading, p.reading);
            minDistance = Math.min(minDistance, p.distance);
            //console.log(a, p.reading, minReading);
            if(p.reading <= minReading) // avoid plotting parallax area
                model.push(p);
        }
        
        return minDistance;
    };
    
    var d2r = Math.PI/180; // deg to rad

    // for every range and angle calc a data point
    var mind = calcOneAngle(0, this.svgModel);
    
    for(var i=0;i<angles.length;i++)
        calcOneAngle(angles[i], this.svgModel);
    
    if(!this.svg)
        this.svg = SVG('scale').attr({ width:"120mm", height:"20mm", preserveAspectRatio:"xMinYMin" }).viewbox(0,0,120,20)
    else
        this.svg.clear();
    
    var group = this.svg.group().transform({scaleX: this.scope.inputs.svgScaleX });
        
    for(var i in this.svgModel)
    {
        var m = this.svgModel[i];
        //console.log(m.reading, m.angle);
        var w = 0.1;
        var h = 0.9;
        var y0 = 0;
        
        if(m.angle == 0) // make y-space for numbers
            y0 = 0.1;
            
        if(m.distance % 10 == 0)
        {
            w=0.4;
            
            if(m.angle == 0)
                group.text(""+m.distance).size(1.2).move(m.reading - w/2.0 -0.50, y0 + 8.75);
        }
        else if(m.distance % 2 == 0)
            h=0.5;
    
        group.rect(w, h).move(m.reading - w/2.0, y0 + anglesOffsets[m.angle]); console.log(10-(m.angle)/5)        
    }
    
    // draw adjustment lines
    group.rect(0.1, 20).move(minLine, 0);  // height 11mm
    group.rect(0.1, 20).move(maxLine, 0);
    
    group.text(this.scope.currentSettingsName).size(3).move(textOffsetX, textOffsetY);
    var px = this.getParallaxReadings(mind);
    if(px)
    {
        var z1 = "", z2 = "", z3 = "";
        for(var i=0;i< px.length; i++)
        {
            if(i<textLinebreak)
                z1 += px[i]+" ";
            else if(i<textLinebreak*2)
                z2 += px[i]+" ";
            else
                z3 += px[i]+" ";
        }
        
        var y = textOffsetY + 3.2;
        if(z1.length > 0) group.text(z1).size(2.5).move(textOffsetX, y);
        if(z2.length > 0) group.text(z2).size(2.5).move(textOffsetX, y+2.6);
        if(z3.length > 0) group.text(z3).size(2.5).move(textOffsetX, y+2.6+2.6);
    }
    
    var xml= document.getElementById('scale').innerHTML;
    document.getElementById('svgxml').innerText = xml;
    //return this.svgModel;
};

Calculator.prototype.getParallaxReadings = function(minReading)
{
    var ret = []; // must not be ""
    
    for(var i = 0; i < this.scope.model.length; i++)
    {
        if(this.scope.model[i].distance > minReading) // normal
            continue;
            
        if(this.scope.model[i].reading > 0)
            ret.push(this.scope.model[i].distance +"/"+ this.scope.model[i].reading);
    }
   
    return ret;
};

Calculator.prototype.saveSvg = function()
{
    //var svgdom = document.getElementById("svgxml").innerText;
    var data = document.getElementById('scale').innerHTML;    
    var blob = new Blob([ data ], {type: "image/svg+xml;charset=utf-8"});
    saveAs(blob, "arrow.svg", true);  // true disables UTF-16/32 Byte Order Mark
};

Calculator.prototype.drawSvgShot = function(drawWhat)
{
    // similar as model, but for X,Y=distance,drop graph
    var max = this.scope.inputs.maxDistance;
    for(var j=0; j<this.scope.inputs.settings.length; j++) // do not discard user data
        if(this.scope.inputs.settings[j].distance > max)
            max = this.scope.inputs.settings[j].distance;
                    
    var step=.5;
    var distDropGraph = []; // [[x1,y1], ...]
    var distScopeGraph = []; // [[x1,y1], ...]
    var distScopePolyfit = []; // [[x1,y1], ...]
    for(var d = 0; d < max; d+=step) // d is the distance to the target           
    {
        if(typeof(this.scope.inputs.maxDistance) == "number" && d > max)
            break;
            
        var time = d/this.scope.inputs.arrow.v0;
        var drop = 9.81/2.0*time*time*10;
        var tuple = [d, drop];
        distDropGraph.push(tuple);
        //console.log(tuple);
        
        var scope = this.evalSpline(d);
        distScopeGraph.push([d, scope]);
        
        scope = this.evalPolyfit(d);
        if(scope > 0)
            distScopePolyfit.push([d, scope]);
    }                        

    if(!this.shotSvg)
        this.shotSvg = SVG('shotSVG').attr({ width:"300mm", height:"200mm", preserveAspectRatio:"xMinYMin" }).viewbox(0,0,300,200)
    else
        this.shotSvg.clear();
    
    var group = this.shotSvg.group().transform({scaleX: 3, scaleY:3 }); // 0..70 m, 0..300 cm
    
    group.fill('none').stroke({ width: 0.06 });
    
    // grid
    for(var i=10;i<=60;i+=10)
        group.line(i,0,i,300);
        
    if(drawWhat==1)
        group.polyline(distDropGraph).stroke({ width: 0.2 });
    else
    {
        group.polyline(distScopeGraph).stroke({ width: 0.2 });    
        group.polyline(distScopePolyfit).stroke({ width: 0.1, color:"#F00" });
    }
};

Calculator.prototype.transformScale = function()
{
    if(!this.transformScaleTo || !this.transformScaleFrom)
        return;
            
    var delta = this.transformScaleTo - this.transformScaleFrom;
    for(var j=0; j<this.scope.inputs.settings.length; j++) // do not discard user data
        this.scope.inputs.settings[j].reading += delta;
        
    this.transformScaleFrom = "";
    this.transformScaleTo = "";
    this.calcModel();    
};


Calculator.prototype.addRemoveTarget = function(i)
{
    if("" == this.scope.parcour.object[i].id)
        this.scope.parcour.object.splice(i,1);
    else
        this.scope.parcour.object.splice(i+1,0,{id:"",d:0,a:0});
};

Calculator.prototype.storeParcour = function() // store many parcours and retrieve them
{
    this.localStorageParcour.store();
};

Calculator.prototype.restoreParcour = function(key) // store many parcours and retrieve them
{
    this.localStorageParcour.restore(key);
    this.updateUrlParameter();
    this.parcourHighlightRow = 0;
};

Calculator.prototype.deleteParcour = function(key) // store many parcours and retrieve them
{
    if(confirm("Delete " + key + "?") === true)
        this.localStorageParcour.delete(key);
};

Calculator.prototype.setHighlightParcour = function(index) // store many parcours and retrieve them
{
    if(this.parcourHighlightRow == index)
        index++;
        
    this.parcourHighlightRow = index;
    localStorage.setItem('ARCHISCOPE_parcour_highlight', this.parcourHighlightRow.toString());
};

Calculator.prototype.advanceHighlightParcour = function() // store many parcours and retrieve them
{
    this.parcourHighlightRow++;
    localStorage.setItem('ARCHISCOPE_parcour_highlight', this.parcourHighlightRow.toString());
};

</script>
</head>
<body>
    <div ng-controller="Calculator">
      <table id="table" style="min-width:260px">
      <tr>
        <th>Arrow Name</th>
        <td><input type="text" ng-model="inputs.arrow.name"></td>
      </tr>
      <tr>
        <th>Arrow grains</th>
        <td><input type="number" ng-model="inputs.arrow.grains"></td>
      </tr>
      <tr>
        <th>V0 fps</th>
        <td><input type="number" ng-model="inputs.arrow.v0fps"></td>
      </tr>
      <tr>
        <th>V0 m/s</th>
        <td><input type="number" ng-model="inputs.arrow.v0"></td>
      </tr>
      <tr class="do-not-print">
        <th>Max Distance</th>
        <td><input type="number" ng-model="inputs.maxDistance" min="30" max="140"></td>
      </tr>
      <tr class="do-not-print">
        <th>Show drop</th>
        <td><input type="checkbox" ng-model="showDrop"></td>
      </tr>
      <tr class="do-not-print">
        <th>Show Polyfit</th>
        <td><input type="checkbox" ng-model="showPolyfit"></td>
      </tr>
      <!-- tr>
        <th>Inclinations</th>
        <td><input type="checkbox" ng-model="inputs.showInclination"></td>
      </tr -->
      <!-- tr>
        <th>Unit Meters</th>
        <td><input type="checkbox" ng-model="inputs.useMeters"></td>
      </tr-->
      <!-- tr>
        <th>Eye-Arrow d (mm)</th>
        <td><input type="number" ng-model="inputs.parallaxDistance"></td>
      </tr -->
      </table>
      
      <br/>

      <table id="table">
      <tr>
        <th colspan=2><input type="text" ng-model="currentSettingsName" style="width:112px"></th>
        <th ng-show="showPolyfit">Fit</td>
        <th> m </th>
        <th> &delta;/m </th>
        <!-- th>10&deg; m</th>
        <th>20&deg; m</th>
        <th>30&deg; m</th>
        <th> m </th>
        <th>40&deg; m</th>
        <th>50&deg; m</th -->
        <th ng-show="showDrop">time s</th>
        <th ng-show="showDrop">drop cm</th>
        <th ng-show="showDrop">?</th>
      </tr> 
      <tr ng-repeat="i in model" ng-class="{parallax: i.distance<calculator.parallax, tenmeters: i.distance % 10 == 0, twometers: i.distance % 2 == 0 && i.distance % 10 != 0 && i.distance>=calculator.parallax}" >
        <td><input type="number" ng-model="i.reading" step="0.05" style="width:45px"></td>
        <td>{{ i.interpolated }} </td>
        <td ng-show="showPolyfit" ng-class="{'polyfit-color-high': i.reading > i.polyfit+0.08, 'polyfit-color-low': i.reading && i.reading < i.polyfit-0.08 }" >{{i.polyfit}}</td>
        <td><button style="width:100%" ng-click="calculator.setExpandedModelDistance(i.distance); calculator.calcModel()">{{i.distance}}m</button></td>
        <td ng-style="i.delta2nd<0 && i.distance>20 ? {'background-color':'#F00'} : {}">{{ i.delta1m }}</td>
        <!-- td style="background-color:#F5FAFF">{{ i.down10}}</td>
        <td style="background-color:#E0F0FF">{{ i.distance < calculator.parallax && " " || i.down20}}</td>
        <td style="background-color:#B8DBFF">{{ i.distance < calculator.parallax && " " || i.down30}}</td>
        <td>{{i.distance}}m</td>
        <td style="background-color:#A3D1FF">{{ i.distance < calculator.parallax && " " || i.down40}}</td>
        <td style="background-color:#DDDDFF">{{ i.distance < calculator.parallax && " " || i.down50}}</td -->
        <td ng-show="showDrop" style="background-color:#FFF">{{i.time}}</td>
        <td ng-show="showDrop" style="background-color:#FFF">{{i.drop}}</td>
        <td ng-show="showDrop" style="background-color:#FFF">{{i.deltaScope}}</td>
      </tr>
      <tr class="tdcontrols do-not-print">
        <th>Save</th>
        <td colspan="99"><button ng-click="saveSettings()">local save</button></td>
      </tr>
      <tr class="tdcontrols do-not-print">
        <th>Bookmark</th>
        <td colspan="99"><a href="index.html#!{{ inputsURI }}" target="_blank">{{ currentSettingsName }}</a></td>
      </tr>
      <tr class="do-not-print">
        <td colspan="99" class="storage-warning">iOS and Android may discard this local data occasionally! Make a bookmark or a screenshot.</td>
      </tr>
      <tr class="do-not-print">
        <th colspan="3">Saved reading</th>
        <th colspan="99">Use</th>
      </tr>
      <tr class="do-not-print" ng-repeat="(key, value) in savedSettings">
        <td colspan="3"><a href="" ng-click="showSavedReadingsExpanded=!showSavedReadingsExpanded">{{ key }}</a></td>
        <td><button ng-click="loadSettings(key)">load</button></td>
        <td ng-if="showSavedReadingsExpanded" ng-repeat="item in savedSettings[key]"> {{ item.distance }}m {{ item.reading }} </td>
        <td ng-if="showSavedReadingsExpanded"><button ng-click="deleteSettings(key)">delete</button></td>
      </tr>
      </table>
      
      
      <br/>
      <table id="parcourTable">
      <tr>
        <th colspan="6"><input type="text" ng-model="parcour.key" style="width:200px; text-align:center;"></th>
      </tr>
      <tr>
        <th>Target<!--button style="float:right" ng-click="calculator.addTarget(0)">+</button--></th>
        <th>sight</th>
        <th>dist.</th>
        <th>&deg;angle</th>
        <th>LofS</th>
      </tr>
      <tr ng-repeat="target in parcour.object" ng-class="calculator.parcourHighlightRow == $index ? 'parcour-highlight-tr' : 'parcour-tr'">
        <td><input type="text" ng-model="target.id" placeholder="1 Eagle" style="width:75px"><button class="do-not-print" ng-show="showEditParcourButtons" ng-click="calculator.addRemoveTarget($index)">{{ target.id ? "+" : "-" }}</button>
            </td>
        <td ng-click="calculator.setHighlightParcour($index)">{{ calculator.evalSpline(target.d).toFixed(2) }}</td>
        <td><input type="number" ng-model="target.d" placeholder="distance" style="width:50px"></td>
        <td><input type="number" ng-model="target.a" placeholder="angle (+/-)" style="width:40px"></td>
        <td ng-click="calculator.advanceHighlightParcour($index)">{{ (target.d / Math.cos(target.a * Math.PI/180.0)).toFixed(2) }}</td>
      </tr>
      <tr class="tdcontrols do-not-print">
        <th>Do</th>
        <td colspan="99">
            <button ng-click="showEditParcourButtons = !showEditParcourButtons">edit</button>
            <button ng-click="calculator.storeParcour()">local save</button>
        </td>
      </tr>
      <tr class="do-not-print">
        <td colspan="6" class="storage-warning">iOS and Android may discard this local data occasionally! Bookmark the current parcour or make a screenshot!</td>
      </tr>
      <tr class="tdcontrols do-not-print">
        <th>Bookmark</th>
        <td colspan="99"><a href="index.html#!{{ parcourURI }}" target="_blank">{{ parcour.key }}</a></td>
      </tr>
      <tr class="do-not-print" ng-repeat="(key, parcour) in parcourStore">
        <td  colspan="3">{{ key }}</td>
        <td><button ng-click="calculator.restoreParcour(key)">load</button></td>
        <td><button ng-click="calculator.deleteParcour(key)">delete</button></td>
      </tr>
      </table>
      <br/>

      
      <br/>
      <table class="do-not-print">
      <tr>
        <th>old reading</th>
        <td><input type="number" ng-model="calculator.transformScaleFrom" placeholder="23.3" style="width:50px"></td>
      </tr>
      <tr>
        <th>new reading</th>
        <td><input type="number" ng-model="calculator.transformScaleTo" placeholder="23.1" style="width:50px"></td>
      </tr>
      <tr>
        <td colspan="99"><button ng-click="calculator.transformScale()">shift scale</button></td>
      </tr>
      <tr class="do-not-print">
        <td colspan="99" class="storage-warning">Adds the change to all readings. Use if you have changed the nocking point or arrow rest, if the change at 10m, or 20m ist exactly the same as at 50m.</td>
      </tr>
      </table>
      <br/>
      
  <table class="do-not-print">
  <tr>
      <th style="width:360px;"><a href="" ng-click="showHelp=!showHelp">Instructions</a></th>
  </tr>
  <tr ng-show="showHelp">
      <td class="helptext-td">
          <p>Enter 3 readings to start: 20m, 30m, 50m. If you have more than 3 values you can use "Show Polyfit" to find 
          bad readings (outliers) that are to high (orange) or low (blue). This will do a 2nd order polynomial fit from 20m to max.
          You can enter yard-readings even if it says meters, just do not mix y and m. Drop does not consider drag.
          </p>
          <p>If you need parallax readings for 3D, shoot at least 3 distances between 15 and 4m. 
          In the parallax-region optical parallax-error, which is function of the straight-line distance to target, outweights the 
          arrow-drop, so fill in these readings carefully. A separate interpolation will deal with the values.
          There is no way to find correct values for e.g. 60 degree uphill/downhill shots at 10m straight line distance, 
          which is 5m arrow-drop distance and 10m parallax distance. A table cannot capture that.
          </p>
          <p>You can create and save parcours separately. To add a target, click "edit" and then the + button. To remove, clear the text and hit the - button.
          Enter the shot distance and degree-angle to calculate the line-of-sight (LofS) and sight-setting. Advance the sight-highlighted row by tapping LofS or set it by tapping any row in the sight column.
          </p>
      <p>Browser vendors decided to make local storage different between HTTP and HTTPS (secure) versions of the page!
      Google announced to disable local storage on insecure origins (non HTTPS). This is very stupid in our case.
      iOS 11 discards Safari localStorage on iOS Upgrade, but preserves it when added as web-app to the homescreen.</p>
      <p>Howto bookmark: (1) open/click the link "Bookmark" above to open in default webbrowser, (2) create bookmark on phone or desktop, (3) repeat after changes!</p>
      <p>CLEAR ALL SAVED DATA INSTANTLY: <button ng-click="clearLocalStorage()">CLEAR</button></p>
      <p>Use this link without data to create standalone web-app on your homescreen: <a href="index.html">Archery Sight</a></p>
      </td>
   </tr>
   </table>
    </div>

    <!-- Advanced Stuff Desktop ... -->
    <center>
        <br/>
        <a href="" ng-click="showScaleAndSVG=!showScaleAndSVG">Show Scope Graphs</a>
        <br/>
    </center>
    <div ng-if="showScaleAndSVG">
        <br/>
        <div id="shotSVG" style="margin:auto; width:210mm; height:200mm; border:1px solid black;">
        </div>
        <br/>
        <center>
            <button ng-click="calculator.drawSvgShot(0)">Draw Scope Readings</button>
            <button ng-click="calculator.drawSvgShot(1)">Draw Shot</button>
            X = Distance 0-70m Y = Arrow drop, Scope reading
        </center>
        <h3>Sight Scale</h3>
        <h5>Shibuya Ultima CPX Scale</h5>
        <p>The Shibuya sight shifts by 1/24' per revolution (1/24×25.4 mm) or 1/480' per click.
        This makes the whole scale 0 ... 10.5 (105 rev) 111.125 mm long and the alignment lines are at readings 0 and 10.5</p>
        <button ng-click="calculator.calcSvgModel('shibuya')">Draw Shibuya</button>

        <h5>Surelock Challenger</h5>
        <p>The Surelock sight has a scale from the reading 0.5 to 88 (measured 86.83 mm) which is 86.83/87.5 = 0.99234285714 mm/revolution.</p>
        <button ng-click="calculator.calcSvgModel('sureloc')">Draw Sureloc</button>
        <br/>
        <br/>
        <div id="scale" style="width:120mm; height:20mm; border:1px solid black; border-left:0px; border-right:0px;"></div>
        <pre id="svgxml"></pre>
        <button ng-click="calculator.calcSvgModel()">Redraw</button>        
        <button ng-click="calculator.saveSvg()">SAVE TO FILE</button>
        <br/>
        Text offset X [mm]: <input type="number" min="0" max="100" step="1" ng-model="calculator.sightTextOffsetX" style="width:50px"> <br/>
        Text offset Y [mm]: <input type="number" min="0" max="17" step="0.1" ng-model="calculator.sightTextOffsetY" style="width:50px"> <br/>
        Fine adjust svg SCALE for printing (0.8 ... 1.5) <input type="number" min="0.8" max="1.5" step="0.002" ng-model="inputs.svgScaleX" style="width:50px">
        <pre>
            1. copy SVG into a file arrow.svg: <button ng-click="calculator.saveSvg()">SAVE TO FILE</button>
            2. open arrow.svg in Crome or Safari and print it.
            3. (fine adjust scale and print final version, if needed)   
        </pre>
            

    </div>
   
</body>
</html>
